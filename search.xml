<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin之旅-数据类型]]></title>
    <url>%2F2018%2F12%2F28%2FKotlin%E4%B9%8B%E6%97%85-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[上一篇文章中，我们对Kotlin有了一个初步的认识，并且写了第一个Kotlin程序，那么，这篇文章说一下Kotlin的数据类型，如下图所示： Boolean类型Kotlin中已经不再区分基本类型和装箱类型了，Kotlin中的Boolean类型相当于Java中的基本类型boolean和装箱类型Boolean的合体，在需要的时候编译器会自动进行转化和区分，下面我们定义一个Boolean的变量b： 1val b: Boolean = true Number类型Number类型主要包括浮点型和整型，具体如下表所示： 分类类型位宽字节Byte8浮点型Double64Float32整型Long64Int32Short16 Kotlin中Number类型基本上和Java相应的基本数据类型使用上基本一致： 1.获取最大值与最小值，如：Int.MAX_VALUE、Int.MIN_VALUE（如此类推）2.可以用二进制、十六进制来表示数值，如用0b00000011表示Int型的3，0xFF表示Int型的2553.与Java一样，当类型不明确时，可以加F、L来标识4.当数值不正确的时候，例如打印0/0的时候，就会输出NaN（即Not A Number），NaN没有比较的意义 类型转换问题：Java中的基本数据类型是可以隐式转换，如下代码所示：12345public class TestDemo &#123; int aInt = 1; long bLong = aInt;&#125; bLong的值是由aInt通过隐式转换的方式赋值过去的，在Java中这段代码是没有任何问题的。但是在Kotlin中这样写就会报错，原因是Kotlin中不允许隐式转换，必须显式转换；12var aInt:Int = 1var bLong:Long = aInt.toLong() 装箱与拆箱问题：1.正如上文所说的，Kotlin中已经不再区分基本数据类型和装箱类型了例如：Kotlin中的Int类型是Java中基本数据类型int和装箱类型Integer的合体，在需要的时候编译器会自动进行转化和区分 Char类型Kotlin中的Char类型对应Java中的Character，大小占2个字节，表示一个16位的Unicode字符，如下：12345fun main(args: Array&lt;String&gt;) &#123; val aChar: Char = 'a' val bChar: Char = '\u0061' println("$aChar + $bChar")//输出：a + a&#125; 说到字符不得不说一下转义字符，如下所示： 转义字符含义\t制表符\b光标后退一个字符\n回车\r光标回到行首\’单引号\”双引号\\反斜杠\$美元符号，Kotlin支持美元符号开头的字符串模板 String类型区间数组]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin之旅-简介]]></title>
    <url>%2F2018%2F12%2F26%2FKotlin%E4%B9%8B%E6%97%85-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Kotlin是由JetBrains公司开发的一门语言，可以运行在Java虚拟机（JVM）、Android（在2017年5月18日的Google开发者大会上，宣布将Kotlin作为Android开发的官方语言）、浏览器、甚至操作系统上的静态强类型语言，可以编译成JavaScript源码，运行在浏览器上，它与java 100%兼容，甚至具备java不具备的新特性。如果你对java非常熟悉，那么你就会发现Kotlin除了自己的标准库之外，大多仍然使用经典的java集合框架。 Kotlin特性Kotlin具有哪些java中没有的特性呢？ 1.空类型安全，避免空指针异常引起的程序崩溃2.全面支持Lambda表达式（java8支持）3.数据类（data class）4.扩展方法5.智能转换6.字符串模板7.类型推导8.区间表达式9.胜任Java能做的所有事情，使用起来比Java简单，例如没有句末分号 第一行代码所谓千里之行，始于Hello World，使用JetBrains公司开发的Intelij IDEA IDE来写Kotlin代码，别提有多爽啦。在写代码之前需要确认一下Kotlin插件有没有安装到IDEA中，如果没有安装需要安装上在进行下面的操作。 然后，创建一个Kotlin的gradle工程，工程名称自己指定； 与java一样，在src目录下创建一个package，创建一个.kt文件： 123fun main(args: Array&lt;String&gt;) &#123; println("Hello World")&#125; 运行程序代码，结果就会输出“Hello World”，我们可以点击println这个方法，看一下它的源码：12345/** Prints the given message and newline to the standard output stream. */@kotlin.internal.InlineOnlypublic actual inline fun println(message: Any?) &#123; System.out.println(message)&#125; 从源码中可以发现调用的就是java中的方法； 那么，Kotlin的HelloWorld工程就编写完了，同时，我们对Kotlin也有了一个大概的认识，了解了Kotlin的一些特性，而这些特性极大方便了程序开发，具体的这些特性，会在后面详细讲的，还请继续关注我的博客！~~~ 最后，有一些学习Kotlin的参考资料，帮助我们更好的学习Kotlin： 1.官方文档2.Kotlin源码3.Kotlin微博4.Kotlin微信公众号：Kotlin5.Gradle文档]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin简介</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[起航]]></title>
    <url>%2F2018%2F12%2F24%2F%E8%B5%B7%E8%88%AA%2F</url>
    <content type="text"><![CDATA[转眼之间一年的时间又匆匆流逝，2018年已接近尾声，2019年如期而至。之前很少写博客，也不是说自己的时间有多忙多忙，总是感觉写博客很浪费时间，故一直没有坚持写博客，现在发现写博客能查漏补缺、温故知新、让你对知识理解的更加深刻，还能分享自己的成长过程或许还能帮助到别人，何乐而不为呢。 总之，以后要坚持写博客，坚持学习，为了成为更好的自己，加油！！！]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>起航</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown规范]]></title>
    <url>%2F2018%2F12%2F23%2FMarkdown%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[欢迎使用Markdown编辑器写博客本Markdown编辑器使用StackEdit修改而来，用它写博客，将会带来全新的体验哦： Markdown和扩展Markdown简洁的语法 代码块高亮 图片链接和图片上传 LaTex数学公式 UML序列图和流程图 离线写博客 导入导出Markdown文件 丰富的快捷键 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y Markdown及扩展 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— [ 维基百科 ] 使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接等，详细语法参考帮助？。 本编辑器支持 Markdown Extra , 扩展了很多好用的功能。具体请参考Github. 表格Markdown Extra 表格语法： 项目 价格 Computer $1600 Phone $12 Pipe $1 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ###定义列表 Markdown Extra 定义列表语法：项目１项目２: 定义 A: 定义 B 项目３: 定义 C : 定义 D &gt; 定义D内容 代码块代码块语法遵循标准markdown代码，例如：12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' ###脚注生成一个脚注[^footnote]. [^footnote]: 这里是 脚注 的 内容. 目录用 [TOC]来生成目录： [TOC] 数学公式使用MathJax渲染LaTex 数学公式，详见math.stackexchange.com. 行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。 块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 更多LaTex语法请参考 这儿. UML 图:可以渲染序列图： 123张三-&gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&gt;张三: 忙得吐血，哪有时间写。 或者流程图： 12345678st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 关于 序列图 语法，参考 这儿, 关于 流程图 语法，参考 这儿. 离线写博客即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入write.blog.csdn.net/mdeditor即可。Markdown编辑器使用浏览器离线存储将内容保存在本地。 用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。 博客发表后，本地缓存将被删除。 用户可以选择 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。 注意：虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，请务必及时发表或者保存到服务器草稿箱。 ##浏览器兼容 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。 IE９以下不支持 IE９，１０，１１存在以下问题 不支持离线功能 IE9不支持文件导入导出 IE10不支持拖拽文件导入]]></content>
      <categories>
        <category>Markdown格式</category>
      </categories>
      <tags>
        <tag>Markdown规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之面向对象]]></title>
    <url>%2F2017%2F02%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。 设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。通俗点说就是软件开发人员在软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 什么是面向对象面向对象（Object Oriented,OO）是软件开发方法，它是基于面向过程而言，是一种对现实世界理解和抽象的方法，是计算机编程技术发展到一定阶段后的产物；一切皆对象！！！ 面向对象的三大特性封装（Encapsulation）：就是把客观事物封装成抽象的类，类就是一个封装了数据以及操作代码的逻辑实体。类可以控制方法和数据的状态，类中私有的属性和方法是无法在外部访问的，表现了封装的隐藏性，增加数据的安全性。 继承（Implementation）：发生在类和类之间，可分为单继承和多层继承描述父子对象之间的血缘关系，最终达到的目的是：一旦使用了继承，子类便获得了父类所有的成员（变量和方法），但是父类的私有方法和属性不能被访问，父类的final成员不能被重写，一旦使用了继承，父类的实例能指向派生类（子类）的引用。 多态（Multipart）：对象在运行期和编译期具有的两种状态，使代码具有灵活性和重用性。编译时多态，也就是函数重载，所谓函数重载就是同一个函数名可以对应多个函数的实现具体调用哪个按照由参数个数、参数类型等来决定。运行时多态，用一个基类的指针或引用来操作多个派生类型的能力被称为多态性。 面向对象类关系针对类关系，之前看过一篇总结很好的博文，当时没有记录，后来想找却找不到了，废话不多说啦……类与类之间关系主要有6种，这6种写法导致了代码不同程度的耦合度，具体如下列所示（耦合度依次增强）：&nbsp;&nbsp;1.依赖关系&nbsp;&nbsp;2.关联关系&nbsp;&nbsp;3.聚合关系&nbsp;&nbsp;4.组合关系&nbsp;&nbsp;5.继承关系&nbsp;&nbsp;6.实现关系 依赖关系依赖就是一个类A使用到了另一个类B，有些英文中将这种关系表述为引用。这种关系具有偶然性、临时性、也非常弱，类B的变化会影响到类A，代码中一般表现为：一个类中对另外一个类的局域变量、方法的形参，或者对静态方法的调用。如下就是一个简单的例子：1234567891011121314151617181920212223242526package virg.code.top;class Code &#123; public void coding(String str) &#123; System.out.println("Using " + str + " !"); &#125;&#125;class Programmer &#123; public void programJava(Code code) &#123; code.coding("java"); &#125; public void programIOS(Code code) &#123; code.coding("IOS"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Programmer programmer = new Programmer(); Code code = new Code(); programmer.programJava(code); programmer.programIOS(code); &#125;&#125; 关联关系关联体现的是两个类之间语义级别的一种强依赖关系，是一种对象之间的引用关系，这种关系比依赖关系要密切很多，不偶然、不临时。一般的，程序中，类A中某个属性的类型是类B，我们称类A和类B的关系就是关联关系，其中类A称为关联类，类B称为被关联类。关联可以是单向的，也可以是双向的。在Java中，关联关系一般使用成员变量来实现。如下就是一个简单的例子：12345678910111213141516171819202122232425262728293031323334package virg.code.top;class Code &#123; public void coding(String str) &#123; System.out.println("Using " + str + " !"); &#125;&#125;class Programmer &#123; private Code mCode; public Programmer(Code code) &#123; this.mCode = code; &#125; //成员变量关联 public void programJava() &#123; mCode.coding("java"); &#125; //形参关联 public void programIOS(Code code) &#123; code.coding("IOS"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Code code = new Code(); Programmer programmer = new Programmer(code); programmer.programJava(); programmer.programIOS(new Code()); &#125;&#125; 从上面观察发现，形参关联既可以表示关联关系，还可以表示依赖关系。 聚合关系聚合关系是关联关系的一种特例，表示的是一种整体与部分的关系。比如：Family和Child，Child是Family的一部分，聚合关系在程序中的体现和上面的关联关系是一样的，也是通过实例变量实现的，只是在语义层面进行区分。可以看出，聚合关系比一般关联关系更强的关系，有整体和部分的联系。如下就是一个简单的例子：1234567891011121314151617181920212223242526272829303132333435363738package virg.code.top;import java.util.ArrayList;import java.util.List;class Child &#123; private String name; public Child(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;class Family &#123; private List&lt;Child&gt; children = new ArrayList&lt;&gt;(); public Family() &#123; children.add(new Child("Tom")); children.add(new Child("Jerry")); &#125; public void getChildrenName() &#123; for (Child child : children) &#123; System.out.println(child.getName()); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Family family = new Family(); family.getChildrenName(); &#125;&#125; 组合关系组合关系也是一种特殊的关联关系，和上面的聚合关系一样，也表示一种整体和部分的关系。但是又不同于聚合组合关系中的部分，离开整体没有意义，只能依附于整体存在。比如，汽车和引擎，引擎是汽车的一部分，离开汽车，引擎在当前的建模语境中没有意义。可以看出，组合是比聚合更强的关联关系。在程序实现中，组合关系和一般的关联关系也没区别，只能从语义层面区分。如下就是一个简单的例子：123456789101112131415161718192021222324252627package virg.code.top;class Engine &#123; public void partEngine() &#123; System.out.println("Engine is part of the car."); &#125;&#125;class Car &#123; private Engine mEngine; public Car(Engine engine) &#123; this.mEngine = engine; &#125; public void hasComponent() &#123; mEngine.partEngine(); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Engine engine = new Engine(); Car car = new Car(engine); car.hasComponent(); &#125;&#125; 意思就是说引擎是汽车的组成的一部分，如果没有引擎，那汽车就不完整了，在炫酷也就是一堆废铁。 继承关系继承关系表示类和类（或者接口与接口）之间的父子关系，Java中有单根继承局限（一个子类只能继承一个父类），但是可以多重继承。子类继承父类，子类就拥有父类非 private 的属性、方法。如下就是一个简单的例子：123456789101112131415161718192021package virg.code.top;class Parent &#123; public void run() &#123; System.out.println("I Can Run..."); &#125;&#125;class Child extends Parent &#123; public void program() &#123; System.out.println("I can Program..."); &#125;&#125;public class Main5 &#123; public static void main(String[] args) &#123; Child child = new Child(); child.run(); child.program(); &#125;&#125; 如上的继承关系，就是说父类具有奔跑（run）的技能，但是他的子类不仅具有奔跑（run）的技能，还具有新的编程技能。 实现关系接口（Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。如下就是一个简单的例子：123456789101112131415161718192021222324package virg.code.top;interface CodeInterface &#123; void code();&#125;class Programmer implements CodeInterface &#123; public void run() &#123; System.out.println("I can run!"); &#125; @Override public void code() &#123; System.out.println("I can coding!"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Programmer programmer = new Programmer(); programmer.run(); programmer.code(); &#125;&#125; 如上实现关系，意思是说有一个Code的技能，谁想学习拥有这个技能谁就实现它，我实现了他，我也就具备技能了。 总结上面提到的面向对象类关系中，继承和实现是纵向的，其他的关系都是类之间的横向关系。关联、聚合、组合只能配合语义，结合上下文才能够判断出来，而只给出一段代码让我们判断是关联，聚合，还是组合关系，则是无法判断的。通过这几种关系能帮助我们在设计类时能够理顺思路，实现上少走弯路。 面向对象的六大原则在运行面向对象的思想进行软件代码编写时，一般需要遵循以下7个基本原则：1.单一职责原则（Single Responsibility Principle）2.开闭原则（Open Close Principle）3.里氏替换原则（Liskov Substitution Principle）4.依赖倒置原则（Dependence Inversion Principle）5.接口隔离原则（Interface Segregation Principle）6.迪米特法则（Law Of Demeter）7.组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP） 之前了解到的都是前6条原则，至于第7条原则也是最近才新增进去，在软件代码编写的时候，我们尽量遵循以上七条设计原则，设计出来的软件一定是一个优秀的软件、足够稳定、代码之间高内聚低耦合，能以更大的灵活性迎接需求的变更等因素。关于这些原则这是一个很深的话题，后面再详细地分析和学习这些原则。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
